# @format

name: Deploy Infrastructure

on:
  push:
    branches:
      - main
      - develop
    paths:
      - "infrastructure/**"
      - ".github/workflows/deploy-infrastructure.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      stacks:
        description: "Stacks to deploy (comma-separated or 'all')"
        required: false
        default: "all"
        type: string

env:
  NODE_VERSION: "22"
  AWS_REGION: ${{ vars.AWS_REGION || 'eu-west-1' }}

permissions:
  id-token: write
  contents: read

jobs:
  # ============================================================================
  # DETERMINE DEPLOYMENT SCOPE
  # ============================================================================
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      stacks: ${{ steps.env.outputs.stacks }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "stacks=${{ github.event.inputs.stacks }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "stacks=all" >> $GITHUB_OUTPUT
          else
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "stacks=all" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # BUILD AND TEST
  # ============================================================================
  build-and-test:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - run: corepack enable

      - name: Install dependencies
        run: make install

      - name: Build infrastructure
        run: make build-infrastructure

      - name: Run tests
        run: make test-infrastructure

      - name: Validate CDK synth
        run: |
          cd infrastructure
          ENVIRONMENT=${{ needs.setup.outputs.environment }} \
          SKIP_DOMAIN_LOOKUP=true \
          yarn cdk synth --all --quiet
        env:
          AWS_ACCOUNT_ID_DEV: ${{ vars.AWS_ACCOUNT_ID_DEV || '123456789012' }}
          AWS_ACCOUNT_ID_STAGING: ${{ vars.AWS_ACCOUNT_ID_STAGING || '123456789012' }}
          AWS_ACCOUNT_ID_PROD: ${{ vars.AWS_ACCOUNT_ID_PROD || '123456789012' }}
          AWS_PIPELINE_ACCOUNT_ID: ${{ vars.AWS_PIPELINE_ACCOUNT_ID || '123456789012' }}

  # ============================================================================
  # APPROVAL GATE (for staging/production)
  # ============================================================================
  approve-deployment:
    runs-on: ubuntu-latest
    needs: [setup, build-and-test]
    if: needs.setup.outputs.environment != 'development'
    environment:
      name: approve-${{ needs.setup.outputs.environment }}
    steps:
      - run: echo "Deployment to ${{ needs.setup.outputs.environment }} approved"

  # ============================================================================
  # DEPLOY INFRASTRUCTURE
  # ============================================================================
  deploy:
    runs-on: ubuntu-latest
    needs: [setup, build-and-test, approve-deployment]
    if: always() && needs.build-and-test.result == 'success' && (needs.approve-deployment.result == 'success' || needs.approve-deployment.result == 'skipped')
    environment: ${{ needs.setup.outputs.environment }}
    concurrency:
      group: deploy-infra-${{ needs.setup.outputs.environment }}
      cancel-in-progress: false

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - run: corepack enable
      - run: make install
      - run: make build-infrastructure

      # Authenticate to pipeline account first
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      # Fetch configuration from pipeline account
      - name: Fetch configuration
        run: |
          echo "Fetching AWS accounts..."
          make fetch-aws-accounts

          echo "Fetching certificate ARN..."
          CERT_ARN=$(aws ssm get-parameter --name "/portfolio/domain/acm-arn" --query "Parameter.Value" --output text 2>/dev/null || echo "")
          if [ -n "$CERT_ARN" ]; then
            echo "CERTIFICATE_ARN=$CERT_ARN" >> $GITHUB_ENV
          fi
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}

      # Assume role in target account
      - name: Assume deployment role
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.DEPLOYMENT_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true

      # Fetch ECR URI from target account
      - name: Fetch ECR URI
        id: ecr
        continue-on-error: true
        run: |
          ECR_URI=$(aws ssm get-parameter \
            --name "/ecr/${{ needs.setup.outputs.environment }}/repository-uri" \
            --query 'Parameter.Value' --output text 2>/dev/null || echo "")
          if [ -n "$ECR_URI" ]; then
            echo "ECR_REPOSITORY_URI=$ECR_URI" >> $GITHUB_ENV
            echo "found=true" >> $GITHUB_OUTPUT
          else
            echo "found=false" >> $GITHUB_OUTPUT
          fi

      # Deploy stacks
      - name: Deploy infrastructure
        run: |
          cd infrastructure

          STACKS="${{ needs.setup.outputs.stacks }}"
          ENV="${{ needs.setup.outputs.environment }}"

          if [ "$STACKS" = "all" ]; then
            # Deploy in dependency order
            yarn cdk deploy \
              NetworkingStack-$ENV \
              LoadBalancerStack-$ENV \
              ComputeStack-$ENV \
              MonitoringStack-$ENV \
              CrossAccountMonitoring-$ENV \
              --require-approval never
          else
            # Deploy specific stacks
            IFS=',' read -ra STACK_ARRAY <<< "$STACKS"
            for stack in "${STACK_ARRAY[@]}"; do
              yarn cdk deploy ${stack}-$ENV --require-approval never
            done
          fi
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
          IMAGE_TAG: ${{ vars.LATEST_IMAGE_TAG || 'latest' }}
          CERTIFICATE_ARN: ${{ env.CERTIFICATE_ARN }}

      # Force ECS update if image changed
      - name: Update ECS service
        if: success()
        continue-on-error: true
        run: |
          aws ecs update-service \
            --cluster ecs-cluster-${{ needs.setup.outputs.environment }} \
            --service ecs-service-${{ needs.setup.outputs.environment }} \
            --force-new-deployment

  # ============================================================================
  # VERIFY DEPLOYMENT
  # ============================================================================
  verify:
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: success()
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.DEPLOYMENT_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true

      - name: Verify stacks
        run: |
          ENV="${{ needs.setup.outputs.environment }}"

          echo "=== Stack Status ==="
          for stack in NetworkingStack LoadBalancerStack ComputeStack; do
            STATUS=$(aws cloudformation describe-stacks \
              --stack-name ${stack}-$ENV \
              --query 'Stacks[0].StackStatus' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            echo "${stack}-$ENV: $STATUS"
          done

      - name: Verify ECS service
        run: |
          aws ecs describe-services \
            --cluster ecs-cluster-${{ needs.setup.outputs.environment }} \
            --services ecs-service-${{ needs.setup.outputs.environment }} \
            --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}' \
            --output table

      - name: Test health endpoint
        continue-on-error: true
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names "${{ needs.setup.outputs.environment }}-alb" \
            --query "LoadBalancers[0].DNSName" --output text)

          echo "Testing: http://${ALB_DNS}/api/health"
          curl -sf "http://${ALB_DNS}/api/health" && echo "✓ Health check passed" || echo "✗ Health check failed"
