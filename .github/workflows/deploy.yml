# @format

name: Deploy

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        type: choice
        options:
          - development
          - staging
          - production

env:
  NODE_VERSION: "22"
  AWS_REGION: ${{ vars.AWS_REGION || 'eu-west-1' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}

permissions:
  id-token: write
  contents: read

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.filter.outputs.frontend }}
      infrastructure: ${{ steps.filter.outputs.infrastructure }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            frontend:
              - 'frontend/**'
            infrastructure:
              - 'infrastructure/**'

  build-frontend:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: always() && (needs.detect-changes.outputs.frontend == 'true' || github.event_name == 'workflow_dispatch')
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}
    outputs:
      image-tag: ${{ steps.image-info.outputs.image-tag }}
      image-uri: ${{ steps.image-info.outputs.image-uri }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - run: corepack enable

      - run: make install

      - run: make test-frontend

      - run: make build-frontend

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Assume deployment role in target account
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.DEPLOYMENT_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true

      - name: Verify target account
        run: |
          CURRENT_ACCOUNT=$(aws sts get-caller-identity --query Account --output text)
          echo "::add-mask::$CURRENT_ACCOUNT"
          echo "TARGET_ACCOUNT_ID=${CURRENT_ACCOUNT}" >> $GITHUB_ENV
          echo "✓ Assumed role in target account"

      - name: Check if ECR exists
        id: check-ecr
        continue-on-error: true
        run: |
          echo "Checking if ECR repository exists..."
          if aws ssm get-parameter --name "/ecr/${{ env.ENVIRONMENT }}/repository-uri" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "✓ ECR repository found in SSM"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::warning::ECR repository not found. Run: ENVIRONMENT=${{ env.ENVIRONMENT }} ./scripts/setup-ecr.sh"
          fi
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Fetch ECR URI
        id: get-ecr-repo
        if: steps.check-ecr.outputs.exists == 'true'
        run: make fetch-ecr-uri
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2
        if: steps.check-ecr.outputs.exists == 'true'

      - uses: docker/setup-buildx-action@v3
        if: steps.check-ecr.outputs.exists == 'true'

      - name: Build and push Docker
        if: steps.check-ecr.outputs.exists == 'true'
        run: make docker-build-push
        env:
          ECR_REPO_URI: ${{ steps.get-ecr-repo.outputs.repository-uri }}
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}

      - name: Set outputs
        id: image-info
        if: steps.check-ecr.outputs.exists == 'true'
        run: |
          echo "image-tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "image-uri=${{ steps.get-ecr-repo.outputs.repository-uri }}:${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Skip notice
        if: steps.check-ecr.outputs.exists != 'true'
        run: |
          echo "::warning::Skipping frontend Docker build - ECR repository not found"
          echo "::warning::Create ECR repository first: ENVIRONMENT=${{ env.ENVIRONMENT }} ./scripts/setup-ecr.sh"

  approve-infrastructure-deployment:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend]
    if: |
      always() && 
      (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped') && 
      needs.detect-changes.outputs.infrastructure == 'true'
    environment:
      name: approve-infrastructure-${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}
    steps:
      - run: echo "::notice::Waiting for manual approval to deploy infrastructure..."

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend, approve-infrastructure-deployment]
    if: |
      always() && 
      (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped') && 
      (needs.approve-infrastructure-deployment.result == 'success' || needs.detect-changes.outputs.infrastructure != 'true')
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}
    concurrency:
      group: deploy-infra-${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}
      cancel-in-progress: false

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - run: corepack enable

      - run: make install

      - run: make build-infrastructure

      - name: Run infrastructure tests
        run: |
          echo "::group::Running infrastructure unit tests"
          make test-infrastructure
          echo "::endgroup::"

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Fetch AWS accounts from pipeline account
        run: make fetch-aws-accounts
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}

      - name: Fetch certificate ARN from pipeline account
        id: fetch-cert
        continue-on-error: true
        run: |
          echo "Fetching certificate ARN from SSM in pipeline account..."
          CERT_ARN=$(aws ssm get-parameter --name "/portfolio/domain/acm-arn" --query "Parameter.Value" --output text 2>/dev/null || echo "")

          if [ -n "$CERT_ARN" ]; then
            echo "Certificate ARN found: ${CERT_ARN:0:50}..."
            echo "CERTIFICATE_ARN=$CERT_ARN" >> $GITHUB_ENV
            echo "cert_configured=true" >> $GITHUB_OUTPUT
          else
            echo "Certificate ARN not found in pipeline account SSM"
            echo "   HTTPS will be disabled"
            echo "cert_configured=false" >> $GITHUB_OUTPUT
          fi
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Verify CDK bootstrap in pipeline account
        run: make verify-cdk-bootstrap
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Check and recover stacks
        id: recover
        continue-on-error: true
        run: ./scripts/recover-stack.sh ${{ env.ENVIRONMENT }}
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          MAX_RETRIES: 3
          RETRY_DELAY: 30

      - name: Recovery status
        if: steps.recover.outcome == 'failure'
        run: |
          echo "::warning::Stack recovery failed or stacks need manual intervention"
          echo "::warning::Deployment will attempt to proceed, but may fail"

      - name: Validate domain configuration
        run: |
          if [ -n "${{ vars.ROOT_DOMAIN_NAME }}" ] && [ -n "${{ vars.HOSTED_ZONE_ID }}" ]; then
            echo "Domain configuration found - HTTPS will be enabled"
          else
            echo "Domain configuration missing - HTTPS will be disabled"
            echo "To enable HTTPS, add GitHub repository variables:"
            echo "  - ROOT_DOMAIN_NAME"
            echo "  - HOSTED_ZONE_ID"
          fi

      - name: Fetch ECR repository URI
        id: fetch-ecr-uri
        continue-on-error: true
        run: |
          echo "Fetching ECR repository URI from SSM..."
          ECR_URI=$(aws ssm get-parameter \
            --name "/ecr/${{ env.ENVIRONMENT }}/repository-uri" \
            --query 'Parameter.Value' \
            --output text \
            --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

          if [ -n "$ECR_URI" ]; then
            echo "::add-mask::$ECR_URI"
            echo "ECR_REPOSITORY_URI=$ECR_URI" >> $GITHUB_ENV
            echo "✓ ECR repository URI found: ${ECR_URI%%/*}/***"
          else
            echo "::warning::ECR repository URI not found in SSM"
            echo "::warning::Will use fallback image. Create ECR with: ./scripts/setup-ecr.sh"
          fi
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - run: make cdk-synth
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}
          IMAGE_TAG: ${{ needs.build-frontend.outputs.image-tag || 'nginx:alpine' }}
          CERTIFICATE_ARN: ${{ env.CERTIFICATE_ARN }}
          ECR_REPOSITORY_URI: ${{ env.ECR_REPOSITORY_URI }}

      - name: Deploy with retry
        id: deploy
        run: |
          max_attempts=2
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Deployment attempt $attempt of $max_attempts"
            if make cdk-deploy; then
              echo "Deployment successful"
              exit 0
            else
              if [ $attempt -lt $max_attempts ]; then
                echo "Deployment failed, waiting 60 seconds before retry..."
                sleep 60
              else
                echo "Deployment failed after $max_attempts attempts"
                exit 1
              fi
            fi
            attempt=$((attempt + 1))
          done
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}
          IMAGE_TAG: ${{ needs.build-frontend.outputs.image-tag || 'nginx:alpine' }}
          CERTIFICATE_ARN: ${{ env.CERTIFICATE_ARN }}
          ECR_REPOSITORY_URI: ${{ env.ECR_REPOSITORY_URI }}

      - name: Post-deployment recovery
        if: failure() && steps.deploy.outcome == 'failure'
        continue-on-error: true
        run: |
          echo "::error::Deployment failed, attempting recovery..."
          make recover-stacks
        env:
          ENV: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Test monitoring setup
        if: success()
        continue-on-error: true
        run: |
          echo "::group::Testing monitoring infrastructure"
          make test-monitoring-e2e ENVIRONMENT=${{ env.ENVIRONMENT }}
          echo "::endgroup::"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Update Prometheus configuration
        if: success()
        continue-on-error: true
        run: |
          echo "::group::Updating Prometheus configuration"
          make update-prometheus-config ENVIRONMENT=${{ env.ENVIRONMENT }}
          echo "::endgroup::"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Force ECS service update
        if: success() && needs.build-frontend.outputs.image-tag != ''
        continue-on-error: true
        run: |
          echo "::group::Forcing ECS service to use new image"
          echo "New image tag: ${{ needs.build-frontend.outputs.image-tag }}"

          # Force new deployment to pick up the new image
          aws ecs update-service \
            --cluster ecs-cluster-${{ env.ENVIRONMENT }} \
            --service ecs-service-${{ env.ENVIRONMENT }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          echo "✓ ECS service update initiated"
          echo "::endgroup::"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

  verify-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    if: success()
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Assume deployment role in target account
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.DEPLOYMENT_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true

      - name: Verify infrastructure health
        run: |
          echo "::group::Verifying infrastructure health"

          # Check ECS service
          echo "Checking ECS service..."
          aws ecs describe-services \
            --cluster ecs-cluster-${{ env.ENVIRONMENT }} \
            --services ${{ env.ENVIRONMENT }}-service \
            --query "services[0].{Status:status,Running:runningCount,Desired:desiredCount}" \
            --output table

          # Check ALB health
          echo "Checking ALB health..."
          aws elbv2 describe-load-balancers \
            --names "${{ env.ENVIRONMENT }}-alb" \
            --query "LoadBalancers[0].{State:State.Code,DNS:DNSName}" \
            --output table

          # Check target health
          echo "Checking target health..."
          LB_ARN=$(aws elbv2 describe-load-balancers \
            --names "${{ env.ENVIRONMENT }}-alb" \
            --query "LoadBalancers[0].LoadBalancerArn" \
            --output text)

          TG_ARN=$(aws elbv2 describe-target-groups \
            --load-balancer-arn $LB_ARN \
            --query "TargetGroups[0].TargetGroupArn" \
            --output text)

          aws elbv2 describe-target-health \
            --target-group-arn $TG_ARN \
            --query "TargetHealthDescriptions[*].{Target:Target.Id,Health:TargetHealth.State}" \
            --output table

          echo "::endgroup::"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Verify monitoring stack
        continue-on-error: true
        run: |
          echo "::group::Verifying monitoring stack"

          # Check if monitoring stack exists
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name "MonitoringEc2Stack-${{ env.ENVIRONMENT }}" \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "NOT_FOUND")

          if [ "$STACK_STATUS" = "CREATE_COMPLETE" ] || [ "$STACK_STATUS" = "UPDATE_COMPLETE" ]; then
            echo "✓ Monitoring stack is healthy: $STACK_STATUS"
            
            # Get monitoring URLs
            GRAFANA_URL=$(aws cloudformation describe-stacks \
              --stack-name "MonitoringEc2Stack-${{ env.ENVIRONMENT }}" \
              --query "Stacks[0].Outputs[?OutputKey=='GrafanaUrl'].OutputValue" \
              --output text)
            
            PROMETHEUS_URL=$(aws cloudformation describe-stacks \
              --stack-name "MonitoringEc2Stack-${{ env.ENVIRONMENT }}" \
              --query "Stacks[0].Outputs[?OutputKey=='PrometheusUrl'].OutputValue" \
              --output text)
            
            echo "::notice::Grafana: $GRAFANA_URL"
            echo "::notice::Prometheus: $PROMETHEUS_URL"
          else
            echo "::warning::Monitoring stack not found or unhealthy: $STACK_STATUS"
          fi

          echo "::endgroup::"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Test application endpoints
        run: |
          echo "::group::Testing application endpoints"

          # Get ALB DNS
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names "${{ env.ENVIRONMENT }}-alb" \
            --query "LoadBalancers[0].DNSName" \
            --output text)

          echo "Testing ALB: $ALB_DNS"

          # Test health endpoint
          echo "Testing /api/health..."
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 "http://${ALB_DNS}/api/health" || echo "000")

          if [ "$HEALTH_STATUS" = "200" ]; then
            echo "::notice::✓ Health endpoint is responding: $HEALTH_STATUS"
          else
            echo "::warning::Health endpoint returned: $HEALTH_STATUS"
          fi

          # Test metrics endpoint
          echo "Testing /api/metrics..."
          METRICS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 "http://${ALB_DNS}/api/metrics" || echo "000")

          if [ "$METRICS_STATUS" = "200" ]; then
            echo "::notice::✓ Metrics endpoint is responding: $METRICS_STATUS"
            
            # Verify metrics format
            METRICS_CONTENT=$(curl -s --connect-timeout 10 "http://${ALB_DNS}/api/metrics")
            if echo "$METRICS_CONTENT" | grep -q "nextjs_up"; then
              echo "::notice::✓ Metrics are in correct Prometheus format"
            else
              echo "::warning::Metrics format may be incorrect"
            fi
          else
            echo "::warning::Metrics endpoint returned: $METRICS_STATUS"
          fi

          echo "::endgroup::"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Deployment summary
        if: always()
        run: |
          echo "::notice::Deployment verification complete for ${{ env.ENVIRONMENT }}"
          echo "::notice::Check the logs above for any warnings or issues"
