# @format

name: Deploy

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        type: choice
        options:
          - development
          - staging
          - production

env:
  NODE_VERSION: "22"
  AWS_REGION: ${{ vars.AWS_REGION || 'eu-west-1' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}

permissions:
  id-token: write
  contents: read

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.filter.outputs.frontend }}
      infrastructure: ${{ steps.filter.outputs.infrastructure }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            frontend:
              - 'frontend/**'
            infrastructure:
              - 'infrastructure/**'

  build-frontend:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: always() && (needs.detect-changes.outputs.frontend == 'true' || github.event_name == 'workflow_dispatch')
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}
    outputs:
      image-tag: ${{ steps.image-info.outputs.image-tag }}
      image-uri: ${{ steps.image-info.outputs.image-uri }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - run: corepack enable

      - run: make install

      - run: make test-frontend

      - run: make build-frontend

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Assume deployment role in target account
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.DEPLOYMENT_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true

      - name: Verify target account
        run: |
          CURRENT_ACCOUNT=$(aws sts get-caller-identity --query Account --output text)
          echo "::add-mask::$CURRENT_ACCOUNT"
          echo "TARGET_ACCOUNT_ID=${CURRENT_ACCOUNT}" >> $GITHUB_ENV
          echo "âœ“ Assumed role in target account"

      - name: Check infrastructure
        id: check-infra
        run: make check-infra
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Fetch ECR URI
        id: get-ecr-repo
        if: steps.check-infra.outputs.exists == 'true'
        run: make fetch-ecr-uri
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2
        if: steps.check-infra.outputs.exists == 'true'

      - uses: docker/setup-buildx-action@v3
        if: steps.check-infra.outputs.exists == 'true'

      - name: Build and push Docker
        if: steps.check-infra.outputs.exists == 'true'
        run: make docker-build-push
        env:
          ECR_REPO_URI: ${{ steps.get-ecr-repo.outputs.repository-uri }}
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}

      - name: Set outputs
        id: image-info
        if: steps.check-infra.outputs.exists == 'true'
        run: |
          echo "image-tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "image-uri=${{ steps.get-ecr-repo.outputs.repository-uri }}:${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Skip notice
        if: steps.check-infra.outputs.exists != 'true'
        run: |
          echo "::notice::Skipping frontend Docker build - infrastructure not deployed yet"

  approve-infrastructure-deployment:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend]
    if: |
      always() && 
      (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped') && 
      needs.detect-changes.outputs.infrastructure == 'true'
    environment:
      name: approve-infrastructure-${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}
    steps:
      - run: echo "::notice::Waiting for manual approval to deploy infrastructure..."

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend, approve-infrastructure-deployment]
    if: |
      always() && 
      (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped') && 
      (needs.approve-infrastructure-deployment.result == 'success' || needs.detect-changes.outputs.infrastructure != 'true')
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}
    concurrency:
      group: deploy-infra-${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'development') }}
      cancel-in-progress: false

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - run: corepack enable

      - run: make install

      - run: make build-infrastructure

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Fetch AWS accounts from pipeline account
        run: make fetch-aws-accounts
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}

      - name: Fetch certificate ARN from pipeline account
        id: fetch-cert
        continue-on-error: true
        run: |
          echo "Fetching certificate ARN from SSM in pipeline account..."
          CERT_ARN=$(aws ssm get-parameter --name "/portfolio/domain/acm-arn" --query "Parameter.Value" --output text 2>/dev/null || echo "")

          if [ -n "$CERT_ARN" ]; then
            echo "Certificate ARN found: ${CERT_ARN:0:50}..."
            echo "CERTIFICATE_ARN=$CERT_ARN" >> $GITHUB_ENV
            echo "cert_configured=true" >> $GITHUB_OUTPUT
          else
            echo "Certificate ARN not found in pipeline account SSM"
            echo "   HTTPS will be disabled"
            echo "cert_configured=false" >> $GITHUB_OUTPUT
          fi
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Verify CDK bootstrap in pipeline account
        run: make verify-cdk-bootstrap
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Check and recover stacks
        id: recover
        continue-on-error: true
        run: ./scripts/recover-stack.sh ${{ env.ENVIRONMENT }}
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          MAX_RETRIES: 3
          RETRY_DELAY: 30

      - name: Recovery status
        if: steps.recover.outcome == 'failure'
        run: |
          echo "::warning::Stack recovery failed or stacks need manual intervention"
          echo "::warning::Deployment will attempt to proceed, but may fail"

      - name: Validate domain configuration
        run: |
          if [ -n "${{ vars.ROOT_DOMAIN_NAME }}" ] && [ -n "${{ vars.HOSTED_ZONE_ID }}" ]; then
            echo "Domain configuration found - HTTPS will be enabled"
          else
            echo "Domain configuration missing - HTTPS will be disabled"
            echo "To enable HTTPS, add GitHub repository variables:"
            echo "  - ROOT_DOMAIN_NAME"
            echo "  - HOSTED_ZONE_ID"
          fi

      - run: make cdk-synth
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}
          IMAGE_TAG: ${{ needs.build-frontend.outputs.image-tag || 'nginx:alpine' }}
          CERTIFICATE_ARN: ${{ env.CERTIFICATE_ARN }}


      - name: Deploy with retry
        id: deploy
        run: |
          max_attempts=2
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Deployment attempt $attempt of $max_attempts"
            if make cdk-deploy; then
              echo "Deployment successful"
              exit 0
            else
              if [ $attempt -lt $max_attempts ]; then
                echo "Deployment failed, waiting 60 seconds before retry..."
                sleep 60
              else
                echo "Deployment failed after $max_attempts attempts"
                exit 1
              fi
            fi
            attempt=$((attempt + 1))
          done
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}
          IMAGE_TAG: ${{ needs.build-frontend.outputs.image-tag || 'nginx:alpine' }}
          CERTIFICATE_ARN: ${{ env.CERTIFICATE_ARN }}

      - name: Post-deployment recovery
        if: failure() && steps.deploy.outcome == 'failure'
        continue-on-error: true
        run: |
          echo "::error::Deployment failed, attempting recovery..."
          make recover-stacks
        env:
          ENV: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}
